

tile.raster.autozoom <- function(bbox, epsg, minnumtiles=12) {
  for(zoom in 1:19) {
    tiles <- tiles.bybbox(bbox, zoom, epsg) #always latlon
    if(nrow(tiles) >= minnumtiles) {
      return(zoom)
    }
  }
}


#' Get Open Street Map Tiles As RasterStack
#'
#' Get Open Street Map tiles as RasterStack object (requires package
#' \code{raster} to be installed) with a Spherical Mercator projection
#' (\href{https://en.wikipedia.org/wiki/Web_Mercator}{epsg:3857}).
#'
#' @param bbox A bounding box as generated by \code{sp::bbox()} or \code{prettymapr::searchbbox()}.
#'          Must be in lon/lat (epsg:4326)!
#' @param zoomin The amount by which to adjust the automatically calculated zoom (or
#' manually specified if the \code{zoom} parameter is passed). Use +1 to zoom in, or -1 to zoom out.
#' @param zoom Manually specify the zoom level (not reccomended; adjust \code{zoomin} or
#' \code{res} instead.
#' @param type A map type; one of that returned by \link{osm.types}. User defined types are possible
#' by defining \code{tile.url.TYPENAME <- function(xtile, ytile, zoom){}} and passing TYPENAME
#' as the \code{type} argument.
#' @param forcedownload \code{TRUE} if cached tiles should be re-downloaded. Useful if
#' some tiles are corrupted.
#' @param cachedir The directory in which tiles should be cached. Defaults to \code{getwd()/rosm.cache}.
#' @details Tiles are fused and projected
#' @return A RasterStack of the fused tiles is returned.
#' @examples
#' \donttest{
#' library(cartography)
#' library(raster)
#' library(prettymapr)
#' data(nuts2006)
#' spdf <- nuts0.spdf[nuts0.spdf$id=="DE",]
#' spdf2 <- spTransform(spdf, CRSobj = CRS("+init=epsg:4326"))
#' x <- osm.raster(bbox(spdf2), type="thunderforestlandscape")
#'
#' ns <- makebbox(47.2, -59.7, 43.3, -66.4)
#' x <- osm.raster(ns)
#' }
#' @export
osm.raster <- function(bbox, zoomin=0, zoom=NULL, type="osm", forcedownload=FALSE, cachedir=NULL) {
  if(!("raster" %in% rownames(installed.packages()))) {
    stop("package 'raster' must be installed for call to osm.raster()")
  }


  if(is.null(zoom)) {
    zoom <- tile.raster.autozoom(bbox, epsg=4326)
  }

  zoom <- min(zoom+zoomin, tile.maxzoom(type))
  zoom <- max(1, zoom) #global min zoom set to 1
  message("Zoom: ", zoom)

  tiles <- tiles.bybbox(bbox, zoom, epsg=4326)
  tile.download(tiles, zoom, type=type, forcedownload=forcedownload, cachedir=cachedir)

  x <- tile.fuse(tiles, zoom, type=type, epsg=3857, cachedir=cachedir)
  arr <- x[[1]]
  box <- x[[2]]
  nbrow <- dim(arr)[1]
  nbcol <- dim(arr)[2]
  raster::stack(raster::raster(matrix(arr[,,1], nrow = nbrow, ncol = nbcol),
                       xmn = box[1,1], xmx = box[1,2],
                       ymn = box[2,1], ymx = box[2,2],
                       crs = "+init=epsg:3857"),
                raster::raster(matrix(arr[,,2], nrow = nbrow, ncol = nbcol),
                       xmn = box[1,1], xmx = box[1,2],
                       ymn = box[2,1], ymx = box[2,2],
                       crs = "+init=epsg:3857"),
                raster::raster(matrix(arr[,,3], nrow = nbrow, ncol = nbcol),
                       xmn = box[1,1], xmx = box[1,2],
                       ymn = box[2,1], ymx = box[2,2],
                       crs = "+init=epsg:3857"))
}


#' @title Project an OSM RasterStack
#' @name osm.proj
#' @description  Project an OSM RasterStack
#' @param osm.raster A RasterStack
#' @param projection A projection as generated by \code{Spatial*@@proj4String} or \code{sp::CRS()}.
#' @param crop.bbox (optional) a bbox to crop the image to (in projected coordinates)
#' @examples
#' \donttest{
#' library(cartography)
#' library(raster)
#' library(prettymapr)
#'
#' data(nuts2006)
#' spdf <- nuts0.spdf[nuts0.spdf$id=="DE",]
#' spdf2 <- spTransform(spdf, CRSobj = CRS("+init=epsg:4326"))
#' x <- osm.raster(bbox(spdf2), type="thunderforestlandscape")
#' x2 <- osm.proj(x, spdf@@proj4string, crop.bbox=bbox(spdf))
#' osm.proj.plot(x2)
#'
#' ns <- makebbox(47.2, -59.7, 43.3, -66.4)
#' x <- osm.raster(ns)
#' osm.proj.plot(osm.proj(x, CRS("+init=epsg:26920")))
#' }
#' @export
osm.proj <- function(osm.raster, projection, crop.bbox=NULL) {
  if(!("raster" %in% rownames(installed.packages()))) {
    stop("package 'raster' must be installed for call to osm.proj()")
  }

  rstackproj <- raster::projectRaster(osm.raster, crs = projection)
  rstackproj@data@values[rstackproj@data@values > 1 ] <- 1
  rstackproj@data@values[rstackproj@data@values < 0 ] <- 0

  if(!is.null(crop.bbox)) {
    k <- min(c(0.052 * (crop.bbox[2,2] - crop.bbox[2,1]),
               0.052 * (crop.bbox[1,2] - crop.bbox[1,1])))
    crop.bbox[2,2] <- crop.bbox[2,2] + k
    crop.bbox[1,1] <- crop.bbox[1,1] - k
    crop.bbox[2,1] <- crop.bbox[2,1] - k
    crop.bbox[1,2] <- crop.bbox[1,2] + k

    return(raster::crop(rstackproj, crop.bbox))
  } else {
    return(rstackproj)
  }
}

#' Plot an OSM RasterStack

#' Plot an OSM RasterStack as generated by \link{osm.proj} or \link{osm.raster}.
#' This function is a thin wrapper to \code{raster::plotRGB()}.
#'
#' @param rgbraster An RGB RasterStack
#' @param ... Arguments to be passed on to \code{raster::plotRGB()}.
#' @export
osm.proj.plot <- function(rgbraster, ...){
  raster::plotRGB(rgbraster, scale = 1, interpolate = TRUE, ...)
}

